#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#define SIZE 50

struct node
{
	char title[SIZE];
	int year;
	struct node* link;
}NODE;

int main()
{
	/*
	 리스트 : 데이터를 저장하는 단위(구조체임)
	 데이터 필드 + 링크필드로 구성된 자료형이다.

	 링크드 리스트 : 여러 개의 링크가 사슬처럼 연결된 자료구조.
	 리스트의 링크필드부분이 다른 리스트를 가리킴
	 링크드 리스트에서 각 요소를 노드라고 한다.
	 
	 헤드포인터 : 첫 번째 노드를 가리키는 포인터
	 마지막 노드의 링크 필드는 NULL이 채워짐



	 그럼 배열을 쓰지 왜 링크드리스트라는 것을 사용함?

	 배열을 쓰면 수정이나 삭제가 복잡할 수 있으나
	 링크드 리스트를 사용하면 수정이나 삭제가 쉽다. (링크드 리스트 = '순차적' >> 중간데이터 접근이 느림) (배열은 중간데이터 접근이 빠름)
	 
	 딱 봐도 링크드리스트가 배열보다 단점이 많은거같은데 왜씀? 

	 이건 메모리 관련해서 뭔가 장점이있어서 >> ?


	 "자기 참조 구조체"

	 typedef struct NODE
	 {
		int data;
		struct NODE *link;
	} NODE;


	 링크드 리스트 생성

	 NODE *p1=NULL;
	 p1=(NODE *)malloc(sizeof(NODE)); 

	 p1->data=10;
	 p1->link=NULL; //첫 번째 리스트의 생성

	 NODE *p2=NULL;
	 p2=(NODE *)malloc(sizeof(NODE));
	 p2->data=20;

	 p2->link=NULL;
	 p1->link=p1;  // 첫 번째 리스트 ~ 두 번째 리스트 연결

	 free(p1);
	 free(p2);
	 



	링크드 리스트 예제 - 소장하고 있는 책의 목록을 관리하는 프로그램(링크드 리스트를 이용하여)

	1. 책 >> 제목, 지은이, 출판연도, 출판사 .. 등 한 권의 책은 여러 개의 정보를 가지고 있음
	2. 이 때 떠올리는게 구조체 배열을 생각할 수 있겠으나, 책이 새로 들어오거나, 폐기해야하는 책이라면 없애는 등 데이터(책)의 in, out이 자주 일어날 것이다.
	3. 따라서 링크드 리스트를 이용하여 구현하는 것이 좋다.

	<구현>
	1) 데이터 필드에는 간단히 제목과 출판 연도만 들어가게 하자.
	2) 링크필드에는 ?

	<알고리즘> - 스스로 생각을 해봐야 한다.

	데이터 구조 선언 : 링크드 리스트 >> 구조체 안에 어떤 정보가 들어가야 할까? 
	멤버 >>>> 제목, 출판연도(데이터 필드), 자기참조 포인터(링크필드) : (char 배열, 50칸) 책의 제목, (int) 출판 연도, (struct node*) 자기참조 포인터
	
	데이터 입력 
		1. 헤더 포인터 하나를 일단 선언
		2. 반복(엔터가 입력될 때 까지)
		리스트 생성 : "struct node", 동적 할당
		리스트 연결 : (링크드리스트)
			첫 번째 입력일 경우 - 링크필드=NULL
			첫 번째 입력이 아닐 경우 - 이전 노드(리스트)의 링크필드 = 현재 노드(리스트) 포인터 & 현재 노드 링크 필드 = NULL
			>>>while(엔터가 입력될 때 까지)
			>>> 첫 번째 입력일 경우, 아닐 경우 >> 조건문!!
		코드를 대충 짜본다면, 다음과 같이 만들 수 있을 것이다.

		while(1)
		{
			데이터를 입력
			if(입력 받은 데이터가 엔터)
				break;
			else
			{
				리스트를 생성
				리스트를 연결
					if(첫 번째 입력이면)
						현재 노드 링크 필드 = NULL;
					else
					{
						이전 노드(리스트) 링크필드 = 현재 노드(리스트) 포인터
						현재 노드 링크필드 = NULL
		}
	
	데이터 출력

	1)헤더 포인터를 이용하여 노드에 하나씩 접근

	반복 (리스트의 링크 필드가 NULL일 때 까지)
		2)노드 정보 출력
		3)포인터를 다음 노드 주소값으로 업데이트

	동적 할당 반환

	


			
	<코드>
	 */
char buffer[SIZE];
	NODE* header;
while (1)
{
	gets_s(buffer, SIZE); //scanf()와 같음
	if (buffer[0] == '\0')
		break;
	NODE
}

	return 0;
	
}